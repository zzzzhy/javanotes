1. 各个数据页组成一个双向链表，每个数据页中的记录值会按主键值从小到大组成一个单向链表。每个数据页都会为存储在它里边儿的记录生
成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速
找到指定的记录。
2. 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。我们的实际用户记录其实都存放在B+树的最底层的节点上。
3.聚簇索引和非聚簇索引的区别：

    聚簇索引：
    - 使用记录是按照主键值的大小进行记录和页的排序。
    - B + 树的叶子节点是存储的是完整的数据记录

    非聚簇索引：
    - 使用记录按照列值得大小进行记录和页的排序
    - B+树的叶子结点存的是列值和主键id
    - 目录项存的不是主键和页号而是列值和页号
4. 什么时候使用索引：
    
    1. 列经常被分组
    2. 经常查询某个范围内的数据
    3. 外键列
    
    ps: 经常更新的列不要使用索引
5. 排查慢查询：
    - MySQL数据库有几个配置选项可以帮助我们及时捕获低效SQL语句：
    
    1，slow_query_log
    这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。
    
    2，long_query_time
    当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。
    
    3，slow_query_log_file
    记录日志的文件名。
    
    4，log_queries_not_using_indexes
    这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快。
    
    - 检测mysql中sql语句的效率的方法
    
    1、通过查询日志
    （1）、Windows下开启MySQL慢查询
    MySQL在Windows系统中的配置文件一般是是my.ini找到[mysqld]下面加上
    代码如下：
    log-slow-queries = F:/MySQL/log/mysqlslowquery。log
    long_query_time = 2
    
    （2）、Linux下启用MySQL慢查询
    MySQL在Windows系统中的配置文件一般是是my.cnf找到[mysqld]下面加上
    代码如下：
    log-slow-queries=/data/mysqldata/slowquery。log
    long_query_time=2
    
    说明：
    log-slow-queries = F:/MySQL/log/mysqlslowquery。
    
    为慢查询日志存放的位置，一般这个目录要有MySQL的运行帐号的可写权限，一般都将这个目录设置为MySQL的数据存放目录；
    long_query_time=2中的2表示查询超过两秒才记录；
6. 事务的四大特性：
    - 原子性：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数
    据库，如果操作失败则不能对数据库有任何影响。
    - 一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必
    须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结
    束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
    - 隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操
    作所干扰，多个并发事务之间要相互隔离。
    - 持久性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下
    也不会丢失提交事务的操作。
7. 事务之间可能产生的问题：
    - 脏读：脏读是指一个事务处理过程里读取了另一个未提交的事务中的数据。
    - 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询
    间隔，被另一个事务修改并提交了。
    - 幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作
    ，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看
    刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可
    重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一
    批数据整体（比如数据的个数）。
    - 可串行化
    
8.MySQL数据库的四种事务隔离级别（默认事务级别为可重复读）
    - Read Uncommitted（读取未提交内容）
    - Read Committed（读取提交内容）
    这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的
    改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的
    commit，所以同一select可能返回不同结果；
    - Repeatable Read（可重读）
     这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另
    一个棘手的问题：幻读 （Phantom Read）。 简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新
    行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
    - Serializable（可串行化） 
      这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共
      享锁。在这个级别，可能导致大量的超时现象和锁竞争。

