- 可伸缩性:指在增加更多资源的情况下（通常指cpu），吞吐量（或者缓解短缺）的提升情况。
1. 当任务在运行和阻塞这两个状态之前转换时，就相当于完成了一次上下文切换。
2. 提升可伸缩性: 1>减少锁的持有时间2>降低锁的粒度3>采用非独占的锁或者非阻塞的锁来代替独占锁。
3. 信号量一般可以实现有界属性和阻塞行为。
5. 死锁恢复的唯一方法就是重启程序
6. 调用者不进入休眠状态，而直接重新调用take方法，这种方法被称为忙等或自旋等待，如果缓存的状态在很长一段时间内都不会发生变化，那么使用这种方法就
会消耗大量的cpu时间。
- **_ReentrantLock_** 
1. 默认是非公平的。
2. 当执行加锁操作时，公平性由于在挂起县城和恢复线程时存在的开销而极大的降低性能。例如，一个线程频繁获取某个锁，那
么该线程便会频繁挂起与恢复，而非公平性的锁，便不会产生如此大的开销。在大多数情况下，非公平性的锁的性能要高于公平性锁
3. 在实际情况中，统计性的非公平性保证----确保被阻塞的线程一定最终会获取到锁已经够用了
4. 当持有锁的时间较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。
5. 当需要一些高级功能的情况下才应该使用ReentrantLock,这些功能包括:可定时的，可轮询的与可中断的锁获取操作，
公平队列，以及非块结构的锁。
6. ReentrantLock是一种独占锁
- **_内置锁_** 
1. 内置锁无法终止一个正在等待获取锁的线程，或者无法再请求获取一个锁时无限地等待下去
- **_信号丢失_**
1. 线程必须等待一个已经为真的条件，但在开始之前没有检查条件谓词。
2. 多个线程可以基于不同的条件谓词在同一个条件队列上等待，因此如果使用notify而不是notifyAll时很容易导致类似于信号丢失的问题。
- **_Condition_** 
1. Condition是一种广义的内置条件队列
- **_ReentrantReadWriteLock_**
1. 基于AQS实现的ReentrantReadWriteLocal使用了一个16位的状态来表示写入锁的计数，并且使用了另一个16位的状态来表示
读取锁的计数。在读取锁上的操作将使用共享的获取方法与释放方法，在写入锁的操作上将使用独占的获取方法与释放方法。
2. AQS在内部维护一个等待线程队列，其中鸡柳了某个线程请求的是独占访问还是共享访问。当锁可用时，如果位于
队列头部的线程执行西融入操作，那么线程会得到这个锁，如果位于队列头部的线程执行读取访问，那么队列在第一个写入
线程之前的所有线程都将获得这个锁。
- **_非阻塞同步机制_**
1. 如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法也被称为非阻塞算法。
2. 非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度
开销，而且非阻塞算法不存在死锁和其他活跃性问题。
- **_CAS_**
1. Case最大的缺陷在于难以围绕着CAS正确地构建外部算法
2. Case还有一个缺点是它将使调用者处理竞争问题(重试，回退，放弃)
- **_原子变量类_**
1. 原子变量类是一种泛化的volatile类
