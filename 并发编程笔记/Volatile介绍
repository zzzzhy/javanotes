1. volatile是轻量级的
synchronized，它在多处理器开发中保证了共享变量的“可见性”。
2. 如果一个字段被声明成volatile，Java线程内存
   模型确保所有线程看到这个变量的值是一致的。
3. 有volatile变量修饰的共享变量进行写操作的时候会多出lock addl $0×0,(%esp);
，Lock前缀的指令在多核处理器下会引发了两件事情。
    - 将当前处理器缓存行的数据写回到系统内存。
    - 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。多处理器下，为了保
    证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的
    数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将
    当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内
    存中把数据读到处理器缓存里。
4. Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声
   言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以
   独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕
   竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和
   Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果
   访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区
   域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁
   定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
5. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel 64处
   理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致
   性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统
   内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的
   缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理
   器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理
   器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。
