- **_java对象头的组成_**
1. MarkWord:存储对象的hashCode或锁信息等
2. ClassMetaDataAddress: 存储到对象数据类型的指针
3. ArrayLength:数组的长度（如果当前对象为数组对象） 
- **_锁的的状态_**
锁有四种状态: 无锁状态，偏向锁状态，轻量级锁状态，重量级状态。
    1. 偏向锁：
    
          - 加锁:当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID,
    以后该线程在进入和退出同步代码块的时候不需要进行CAS操作来加锁和解锁，只需要简单的测试一下
    对象头里的MarkWord里是否存储着指向当前线程的偏向锁。测试成功，代表当前线程已经获得了锁，测试失败，
    则会测试该锁是否是偏向锁，若是，尝试使用CAS将对象头的偏向锁指向当前线程。
    若不是，那么使用CAS竞争锁。偏向锁使用了这一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁
    时，持有锁的线程才会释放锁。
    
        - 撤销:需要等待全局安全点(在这个时间上没有正在执行的字节码)。它会暂停
    拥有偏向锁的线程，然后检查该线程是否活着，如果没有活着，则将对象头设置为无锁状态，如果线程活着，拥有偏向锁的
    栈会被执行。        
    2. 轻量级锁: 
        - 加锁: 线程在执行同步块直线，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord复制
        到锁记录中，官方称之为Displaced Mark Word。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。
        如果成功， 当前线程获得锁，如果失败，表示其他线程获得了锁，当前线程便尝试使用自旋来获取锁。
        - 解锁： 使用原子的CAS操作将Displaced MarkWord 替换回到对象头，如果成功，则便是没有竞争发生。如果失败，表示当前锁
        存在竞争，锁就会膨胀成重量级锁。
- **_优缺点比较_**
    1. 偏向锁: 
        - 优点: 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距
        - 缺点： 如果存在锁竞争，会带来额外的锁撤销的消耗。
        - 适用场景: 适用于只有一个线程访问同步块的场景
    2. 轻量级锁:
        - 优点: 竞争的线程不会阻塞，提高了线程的响应速度
        - 缺点： 如果始终得不到锁竞争的线程，使用自旋会消耗cpu
        - 适用场景: 追求响应时间，同步块执行速度非常快
    3. 重量级锁: 
        - 优点: 线程竞争不适用自旋，不会消耗cpu
        - 缺点：线程阻塞，响应速度缓慢
        - 适用场景： 追求吞吐量，同步块执行速度比较长
- **_ReentrantLock(可重入锁)_** 
1. 默认是非公平的。
2. 当执行加锁操作时，公平性由于在挂起县城和恢复线程时存在的开销而极大的降低性能。例如，一个线程频繁获取某个锁，那
么该线程便会频繁挂起与恢复，而非公平性的锁，便不会产生如此大的开销。在大多数情况下，非公平性的锁的性能要高于公平性锁
3. 在实际情况中，统计性的非公平性保证----确保被阻塞的线程一定最终会获取到锁已经够用了
4. 当持有锁的时间较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。
5. 当需要一些高级功能的情况下才应该使用ReentrantLock,这些功能包括:可定时的，可轮询的与可中断的锁获取操作，
公平队列，以及非块结构的锁。
- Lock接口提供的Synchronized关键字不具备的主要特性。
1. 尝试非阻塞地获取锁
2. 能够被中断的获取锁
3. 超时获取锁。
- **_ReentrantReadWriteLock(读写锁)_**
1. 基于AQS实现的ReentrantReadWriteLocal使用了一个整形变量(32位)，“按位切割使用”变量，高16位的状态来表示读锁的计数，低16位的状态来表示
写入锁的计数。在读取锁上的操作将使用共享的获取方法与释放方法，在写入锁的操作上将使用独占的获取方法与释放方法。
2. 假设当前的状态为S,S & 0x0000FFFF(将高16位全部抹去)就是写状态，S>>>16(无符号补0右移16位)就是读状态。当写状态增加1时，等于S+1,
当读状态增加1时,等于S+(1<<16),也就是S+0x00010000
3. AQS在内部维护一个等待线程队列，其中包含了某个线程请求的是独占访问还是共享访问。当锁可用时，如果位于
队列头部的线程执行写入操作，那么线程会得到这个锁，如果位于队列头部的线程执行读取访问，那么队列在第一个写入
线程之前的所有线程都将获得这个锁。
- 锁降级
1. 锁降级是指把持住（当前拥有的）写锁，再获取到
读锁，随后释放（先前拥有的）写锁的过程。
