- 可伸缩性:指在增加更多资源的情况下（通常指cpu），吞吐量（或者缓解短缺）的提升情况。
1. 当任务在运行和阻塞这两个状态之前转换时，就相当于完成了一次上下文切换。
2. 提升可伸缩性: 1>减少锁的持有时间2>降低锁的粒度3>采用非独占的锁或者非阻塞的锁来代替独占锁。
3. 信号量一般可以实现有界属性和阻塞行为。
5. 死锁恢复的唯一方法就是重启程序
6. 调用者不进入休眠状态，而直接重新调用take方法，这种方法被称为忙等或自旋等待，如果缓存的状态在很长一段时间内都不会发生变化，那么使用这种方法就
会消耗大量的cpu时间。
6. ReentrantLock是一种独占锁
- **_内置锁_** 
1. 内置锁无法终止一个正在等待获取锁的线程，或者无法再请求获取一个锁时无限地等待下去
- **_信号丢失_**
1. 线程必须等待一个已经为真的条件，但在开始之前没有检查条件谓词。
2. 多个线程可以基于不同的条件谓词在同一个条件队列上等待，因此如果使用notify而不是notifyAll时很容易导致类似于信号丢失的问题。
- **_Condition_** 
1. Condition是一种广义的内置条件队列
- **_非阻塞同步机制_**
1. 如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或挂起，那么这种算法也被称为非阻塞算法。
2. 非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度
开销，而且非阻塞算法不存在死锁和其他活跃性问题。
- **_CAS_**
1. CAS最大的缺陷在于难以围绕着CAS正确地构建外部算法
2. CAS还有一个缺点是它将使调用者处理竞争问题(重试，回退，放弃)
3. 容易产生ABA问题
4. 循环时间长，开销大
5. 只能保证一个共享变量的原子操作。
- **_原子变量类_**
1. 原子变量类是一种泛化的volatile类
- **_上下文切换_**
1. CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，
以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。
2. 减少上下文切换的方式：减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。
    - 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一
   些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
    - CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
    - 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这
  样会造成大量线程都处于等待状态。
    - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
- **_等待通知方法_**
1. 等待通知方法是任何对象都具备的。因为这些方法被定义在所有对象的父类java.lang.Object上。
2. 调用wait(),notify(),notifyAll()方法需要注意的细节:
    - 使用wait(),notify(),notifyAll()方法需要先获得对象的锁。
    - 调用wait方法后，线程状态由运行状态变为等待状态，并将当前线程放置到对象的等待队列上。
    - notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifyAll()方法的线程释放锁之后，
    等待线程才有机会从wait返回。
    - notify()方法是将等待队列中的一个线程从等待队列移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到
    同步队列，被移动的线程状态由等待态变为阻塞态。
    - 从wait()方法返回的前提是获得了调用对象的锁。
- **_管道输入/输出流_**
1. 管道输入流:PipedOutputStream,PipedInputStream,PipedReader和PipedWriter，前两种面向字节，后两种面向字符。它主要用于线
程之间数据的传输。
- **_Thread.join()_**
1. 如果一个线程A执行了另一个线程B的B.join()方法，其含义是:当前线程A等待线程B终止之后才从B.join()返回。

