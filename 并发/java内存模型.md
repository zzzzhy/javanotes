1. 在java中，只有实例域，静态域和数据元素都存储在堆内存中。

- **_重排序_**
1. 在执行程序时，为了提升性能，编译器和处理器常常会对指令做重排序。对于编译器，JMM会禁止特定类型的编译器重排序。对于
处理器重排序，JMM的处理器重排序则会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定
类型的处理器重排序。

- **_happens-before_**
1. happens-before仅仅要求前一个操作(执行的结果)对后一个操作可见。

- **_as-if-serial语义_**
1. 不管怎么重排序，单线程的执行结果不能改变.

- **_顺序一致性模型_**

    1. 一个线程中的所有操作必须按照程序的顺序来执行
    2. 所有的线程都只能看到一个单一的操作执行顺序。在顺序一致性内存中，每个操作都必须原子执行且立刻对
    所有线程可见。
    - 如果程序是正确同步的，程序的执行讲具有顺序一致性。
- **_总线_**
在计算机中，数据通过总线在处理器和内存之间传递。总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，
总线会禁止其他的处理器和I/O设备执行内存的读/写。总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式
来执行。
- **_锁的内存语义_**
1. 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
2. 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。
- **_final的内存语义_**
1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量之间不能重排序
2. 初次读一个包含域的对象写入，与随后初次读这个final域，这两个操作之间不能重排序。
3. JMM禁止编译器把final域的写入重排序到构造函数之外。
4. 在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。
5. 如果final域为一个引用类型，在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用
赋值给一个引用变量，这两个操作之间不能重排序。
6. 在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中'逸出'。
