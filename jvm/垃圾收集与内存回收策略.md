- 判断对象的存活状态
1. 引用计数法，难以解决对象之间循环相互引用的问题。
2. 可达性分析，通过一系列的称为"GC Roots"作为起始点，从这些节点开始向下搜索，
   搜索所走过的路径称为引用链（Reference chain）,当一个对象到GC Roots没有任何的引用链相连时，则证明该对象是不可用的。
   - 可作为GC roots的对象有:
   1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
   2. 方法区中类静态属性引用的对象
   3. 方法区中常量引用的对象。
   4. 本地方法栈中Native方法引用的对象。
- 垃圾收集算法
    1. 标记-清除算法： 效率问题，标记和清除过程都不高。空间问题，容易产生不连续的空间碎片。
    2. 复制算法：可用内存分成两块，每次只是用一块，当一块使用完了，就将剩余存活的对象复制到另一块。现在很多商业虚拟机都
    采用这个算法来回收新生代，将内存分外一块比较大的eden区和另一块比较小的survivor区。默认比例是8:1。该算法在存活率比较
    高的情况下要进行较多的复制操作，效率比较低。而且需要额外空间作为担保。
    3. 标记整理算法: 标记过程与“标记-清除”算法过程一样，但后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向
    另一端移动。
    4. 现代商业虚拟机大多使用分代收集算法，即新生代使用复制算法，老年代使用标记清除或者标记整理算法。
- 垃圾收集器
    1. Serial收集器，单线程，简单而高效，适用于新生代的收集，对于运行在client模式下的虚拟机是一个很好的选择。
    2. ParNew收集器，Serial收集器的多线程版本，适用于新生代的收集，只有它可以和CMS收集器配合工作。
    3. Parallel Scavenge收集器，新生代收集器，使用复制算法，并行的多线程收集器，吞量优先。
    4. Serial Old收集器，单线程收集器，使用标记整理算法，适用于老年代的收集
    5. Parallel old收集器，Parallel Scavenge收集器的老年代版本使用标记整理算法,吞吐量优先。
    6. CMS（concurrent mark sweep）收集器，是一种以获取最短回收停顿时间为目标的收集器。适用于老年代的收集。收集过程:
        1. 初始标记
        2. 并发标记
        3. 重新标记
        4. 并发清除
        
        1和3仍然需要“stop the world”,由于整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作，所以从总体上
        来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。
        
        优点: 并发收集，低停顿
        
        缺点: 对cpu资源敏感，无法处理浮动垃圾，会产生大量空间碎片
    7. G1收集器，是一款面向服务端应用的垃圾收集器。
        - G1将整个java堆划分为多个大小相等的独立区域(Region)，虽然还保留老年代和新生代的概念，但新生代和老年代已经不再是
        物理隔离了，他们都是一部分Region的(不需要再连续)集合。G1会根据每个Region的垃圾堆积划分出一个优先级列表，会优先收集
        收集价值比较高的Region。
- 内存分配
   1. 大多数情况下，对象在新生代Eden区中分配。
   2. 对象在eden区出生，并在一次MinorGC后进入Survivor区，对象在Survivor区每熬过一次minorGC，对象的年龄就增加一岁，当对象
   的年龄大于一定程度后（默认15岁），该对象就会进入老年代。若在Survivor区中所有年龄相等的对象占用空间超过了survivor区的
   一半大小，此时年龄大于等于该年龄的对象就会进入老年代。
