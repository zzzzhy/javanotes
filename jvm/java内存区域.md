- 运行时的数据区域:
1. 线程共享的: 方法区，堆
    - 堆
    java堆是存放对象实例的区域，几乎（并不是所有）所有的对象实例都在这里分配内存。java堆是垃圾收集
    的主要区域，因此又叫"GC"堆。从内存回收角度看，java堆可以分为新生代和老年代，细致可以分为:eden区，
    From Survivor空间，to Survivor空间。从内存分配角度看，java堆中可能划分多个线程私有的分配缓冲区。
    java堆可以处于内存上不连续的空间，只要逻辑上连续即可。堆的大小一般是可扩展的（同过Xms,Xmx控制），
    如果堆中没有完成实例分配，并且堆也无法再扩展，将会抛出OutOfMemoryError异常。
    - 方法区
    用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收
    目标主要是对常量池的回收和对类型的卸载。
        - 运行时常量池
        运行时常量池是方法区的一部分，Class文件中有类的版本，字段，方法，接口等描述信息外，还有一项信息
        是常量池，用于存放编译器的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池
        中存放。
2. 线程非共享（私有）的: 虚拟机栈，本地方法栈，程序计数器。
    - 程序计数器
    程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的
    概念模型里，字节码解释器工作时就是通过改变这个计数器的值来取需要执行的下一条字节码指令，
    分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器完成。此内存区域，是唯一
    一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。java方法有程序计数器，并且
    记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，则这个计数器值为空。
    - java虚拟机栈
    java虚拟机栈是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型，
    每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等
    信息。每一个方法从调用直到执行完成的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。
    如果线程请求的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。如果虚拟机支持
    动态扩展(大部分虚拟机都支持)，但是如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。
    - 本地方法栈
    本地方法栈与虚拟机栈功能类似，只不过虚拟机栈是为Java方法栈服务，本地方法栈为native方法服务，
    在hotSpot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError
    和OutOfMemoryError。
- 直接内存
    1. 在jdk1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以
    使用Native函数库直接分配堆外内存，然后通过一个存在java堆中的DirectByte对象作为这块内存的引用
    进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。
- **_jvm对象_**
1. 内存分配
    - 指针碰撞: 假设java堆是绝对规整的，所有用过的空间在一边，没有用过的放在另一边，中间放着一个
    指针作为分界点的指示器，那所分配的内存就是仅仅把那个指针从空间空间那边挪动一段与对象大小相等
    的距离,这中分配方式就是指针碰撞。
    - 空闲列表: 如果java堆的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地
    进行指针碰撞了，虚拟机就必须维护一个表，记录那些内存是可用的，在分配的时候从列表中找出一块足够
    大的划分给对象实例，并更新列表上的记录，这种分配方式成为空闲列表(free list)
    - tips:1.对象所需的内存大小在类加载完成后便可完全确定。2.java堆是否规整又由所采用的垃圾收集器
    是否带有压缩整理功能决定。因此，在使用Serial,ParNed等带Compact过程的收集器时，采用“指针碰撞”
    方法，而使用CMS这种基于Mark-Sweep这种收集器时，通常采用空闲列表。
2. 对象的访问定位
    - java程序需要通过栈上的reference数据来操作堆上的具体对象。
    - 目前主流的访问方式有使用句柄和直接指针两种。
        - 使用句柄: java堆中会直接分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而
        句柄中包含了对象实例数据与类型数据各自的具体地址信息。
        ![使用句柄](https://github.com/zzzzhy/javanotes/blob/master/image/%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png)
        - 使用直接指针: reference中存储的直接是对象地址，对象地址信息中包含到对象类型数据的指针。
        ![直接指针](https://github.com/zzzzhy/javanotes/blob/master/image/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png)