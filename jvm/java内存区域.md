- 运行时的数据区域:
1. 线程共享的: 方法区，堆
    - 堆
    java堆是存放对象实例的区域，几乎（并不是所有）所有的对象实例都在这里分配内存。java堆是垃圾收集
    的主要区域，因此又叫"GC"堆。从内存回收角度看，java堆可以分为新生代和老年代，细致可以分为:eden区，
    From Survivor空间，to Survivor空间。从内存分配角度看，java堆中可能划分多多个线程私有的分配缓冲区。
    java堆可以处于内存上不连续的空间，只要逻辑上连续即可。堆的大小一般是可扩展的（同过Xms,Xmx控制），
    如果堆中没有完成实例分配，并且堆也无法再扩展，将会抛出OutOfMemoryError异常。
    - 方法区
    用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收
    目标主要是对常量池的回收和对类型的卸载。
        - 运行时常量池
        运行时常量池是方法区的一部分，Class文件中有类的版本，字段，方法，接口等描述信息外，还有一项信息
        是常量池，用于存放编译器的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池
        中存放。
2. 线程非共享（私有）的: 虚拟机栈，本地方法栈，程序计数器。
    - 程序计数器
    程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的
    概念模型里，字节码解释器工作时就是通过改变这个计数器的值来取需要执行的下一条字节码指令，
    分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器完成。此内存区域，是唯一
    一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。java方法有程序计数器，并且
    记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，则这个计数器值为空。
    - java虚拟机栈
    java虚拟机栈是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型，
    每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等
    信息。每一个方法从调用直到执行完成的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。
    如果线程请求的栈深度大于虚拟机所允许的栈深度，将抛出StackOverflowError异常。如果虚拟机支持
    动态扩展(大部分虚拟机都支持)，但是如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。
    - 本地方法栈
    本地方法栈与虚拟机栈功能类似，只不过虚拟机栈是为Java方法栈服务，本地方法栈为native方法服务，
    在hotSpot虚拟机中，直接将本地方法栈和虚拟机栈合二为一。本地方法栈也会抛出StackOverflowError
    和OutOfMemoryError。
- 直接内存
    1. 在jdk1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以
    使用Native函数库直接分配堆外内存，然后通过一个存在java堆中的DirectByte对象作为这块内存的引用
    进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。
    
