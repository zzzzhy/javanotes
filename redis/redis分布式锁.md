1. 官方叫做 RedLock 算法，是 redis 官方支持的分布式锁算法。

    这个分布式锁有 3 个重要的考量点：
    - 互斥（只能有一个客户端获取锁）
    - 不能死锁
    - 容错（只要大部分 redis 节点创建了这把锁就可以）
2. redis最普通的分布式锁:

    第一个最普通的实现方式，就是在 redis 里使用 setnx 命令创建一个 key，这样就算加锁。
    SET resource_name my_random_value NX PX 30000
    
    执行这个命令就 ok。
     NX：表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）
     PX 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了
     
     释放锁就是删除 key ，但是一般可以用 lua 脚本删除，判断 value 一样才删除：
 3. redLock算法
    
    这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：
    
    获取当前时间戳，单位是毫秒；
    跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
    尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；
    客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
    要是锁建立失败了，那么就依次之前建立过的锁删除；
    人建立了一把分布式锁，你就得不断轮询去尝试获取锁。只要别
4. redis 分布式锁和 zk 分布式锁的对比

    - redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。
    - zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。
    
    另外一点就是，如果是 redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建
    的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。